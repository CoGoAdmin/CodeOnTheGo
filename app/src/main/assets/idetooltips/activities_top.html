<!DOCTYPE html>
<a name="act_intro_onCreate"><a name="act_intro_onStart"><a name="act_intro_onResume"><a name="act_intro_onPause"><a name="act_intro_onStop"><a name="act_intro_onDestroy"><a name="act_intro_state_memory_eject"><a name="act_intro_transient_UI_state"><a name="act_intro_instance_state"><a name="act_intro_save_instance_state"><a name="act_intro_restore_activity_ui"><html lang="en"></a></a></a></a></a></a></a></a></a></a></a>
   
<script src="toggle.js"></script>
<link rel="stylesheet" href="style.css"> 
<title>Introduction to Activities</title>
<html>
<a name="act_intro_declare_intentfilters"><body></a> 
<h1><a name="act_intro_top"></a>Introduction to Activities</h1>
<p>The <code>Activity</code> class is a crucial component of an Android app. The way activities are launched and put together is a fundamental part of the platform's application model. Unlike programming paradigms in which apps are launched with a <code>main()</code> method, the Android system initiates code in an Activity instance by invoking specific callback methods that correspond to specific stages of its lifecycle.
</p><p>This document introduces the concept of <code>activities</code> and  provides some lightweight guidance about how to work with them. </p>
<h2>The concept of activities</h2>
<p>Using a mobile app is different from using a desktop application. On a mobile app, the user's interaction with the app doesn't always begin in the same place. For instance, if you open an email app from your home screen, you might see a list of emails. By contrast, if you are using a social media app that then
launches your email app, you might go directly to the email app's screen for
composing an email.
</p><p>
The <code> Activity</code> class makes it possible to control an app's activity based on a user's prior actions.  When one app invokes another, the calling app invokes the right activity in the other
app. The activity acts as the entry point for an app's interaction with the user.  Activities are implemented as a subclass of the <code>Activity</code> class.
</p><p>
An activity provides the window in which the app draws its UI. This window typically fills the screen, but can be smaller than the screen and float on top of other windows. Generally, one activity
implements one screen in an app. For instance, one of an app's activities may
implement a <em>Preferences</em> screen, while another activity implements
a <em>Select Photo</em> screen.
</p><p>
Most apps contain multiple screens, which means they contain multiple
activities. Typically, the first screen that appears when the user launches the app is specified as the <em>main activity</em>. Then, the main activity can start another activity in order to perform different actions. For example, the main activity in a simple email app may provide the screen that shows an email inbox. From there, the main
activity might launch other activities that provide screens for tasks like
writing emails and opening individual emails.
</p><p>
Although activities work together to form an app's user experience, each activity is only loosely bound to the other activities. Typically, there are minimal dependencies among the activities in an app. 
</p><p>
To use activities in your app, you must:<ul>
<li> Register information about them in the app's manifest
<li> Manage the activity lifecycles.</ul>
<p>The rest of this document introduces these subjects.
<a name="act_intro_manifest_top"><a name="act_intro_manifest_declare_act"></p><h2>Configuring the manifest</h2></a></a>
<p> For an app to use activities, you must declare the activities and some of their attributes in the manifest. </p>
<h3 id="da" data-text="Declare activities" tabindex="-1">Declare activities</h3>
<p>
<p>To declare your activity, follow these steps:</p><ol>
<li>Open your manifest file.
<li>Add an "activity" element as a child of the "application"
element. Here is an example:</ol>   
 <pre>&lt;manifest ... &gt;
  &lt;application ... &gt;
      &lt;activity android:name=".ExampleActivity" /&gt;
      ...
  &lt;/application ... &gt;
  ...
&lt;/manifest &gt;
</pre>   

<p>The only required attribute for this element is
<code>android:name</code>, which specifies the class name of the activity. You can also add attributes
that define activity characteristics such as label, icon, or UI theme.
For more information about these and other attributes...
</p><p class="note">
<strong>IMPORTANT: </strong>After you publish an app, you should not change activity
names. If you do, you might break some functionality, such as app shortcuts.

</p><h3>Declare intent filters</h3><p>
<em>Intent filters</em> make it possible to launch an activity based on an
<em>explicit</em> or an <em>implicit</em> request. <ul>
<li>An explicit request tells the system exactly what to do. For example, an explicit request might tell the system to "Start the Send Email activity in the Gmail app." 
<li>An implicit request tells the system what it wants to accomplish and lets the system make the bst choice. For example, an implicit request tells the system to "Start a Send Email screen in any
activity that can do the job." </ul></p><p>
You can take advantage of this feature by declaring an
<code>"intent-filter"</code>
attribute in the 
<code>"activity"</code> element. The definition of this element includes an
<code>"action"</code> element and,
optionally, a
<code>"category"</code>
element and/or a <code>"data"</code>
element. These elements
combine to specify the type of intent to which your activity can respond. For
example, the following code example shows how to configure an activity that
sends text data, and receives requests from other activities to do so:
</p><div></div><devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="XML">"activity<span class="devsite-syntax-w"> </span>android:name=".ExampleActivity"<span class="devsite-syntax-w"> </span>android:icon="@drawable/app_icon""
<span class="devsite-syntax-w">    </span>"intent-filter"
<span class="devsite-syntax-w">        </span>"action<span class="devsite-syntax-w"> </span>android:name="android.intent.action.SEND"<span class="devsite-syntax-w"> </span>/"
<span class="devsite-syntax-w">        </span>"category<span class="devsite-syntax-w"> </span>android:name="android.intent.category.DEFAULT"<span class="devsite-syntax-w"> </span>/"
<span class="devsite-syntax-w">        </span>"data<span class="devsite-syntax-w"> </span>android:mimeType="text/plain"<span class="devsite-syntax-w"> </span>/"
<span class="devsite-syntax-w">    </span>"/intent-filter"
"/activity"</pre></devsite-code>
<p>
In this
example, the <code>"action"</code>
element specifies that this activity sends data.
Declaring the <code>"category"</code>
element as <code translate="no" dir="ltr">DEFAULT</code> enables the activity
to receive launch requests. The <code>"data"</code>
element specifies the type of data that
this activity can send. The following code example shows how to call the
activity described above:
<code>Example here</code>, Link to more info about Intents and Filters here </p>
<h3>Declare permissions</h3></a></a>
<p>
You can use the manifest's
<code>"activity"</code> tag to control
which apps can start a particular activity. A parent activity cannot launch a
child activity unless both activities have the same permissions in their
manifest. If you declare a
  <code>"uses-permission"</code>
element for a parent activity, each child activity must have a matching
<code>"uses-permission"</code></a>
element.
</p><p>
For example, if your app wants to use a hypothetical app named SocialApp
to share a post on social media, SocialApp itself must define the permission
that an app calling it must have:
</p><div></div><devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="XML">"manifest";activity<span class="devsite-syntax-w"> </span>android:name="...."
<span class="devsite-syntax-w">   </span>android:permission="com.google.socialapp.permission.SHARE_POST"/</pre></devsite-code><p>
Then, to be allowed to call SocialApp, your app must match the permission set in
SocialApp's manifest:
<--!Fix this stuff--></p><div></div><devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="XML">"manifest"
<span class="devsite-syntax-w">   </span>"uses-permission<span class="devsite-syntax-w"> </span>android:name="com.google.socialapp.permission.SHARE_POST"<span class="devsite-syntax-w"> </span>/"
"/manifest"</pre></devsite-code><p>
For more information on permissions and security in general, click here.
</p>
<h2 id="mtal" data-text="Managing the activity lifecycle" tabindex="-1">Managing the activity lifecycle</h2>
<p>
Over the course of its lifetime, an activity goes through a number of states.
You use a series of callbacks to handle transitions between states. The following sections  introduce these callbacks.
</p>
<h3>onCreate()</h3>
<p>
You must implement this callback, which fires when the system first creates the activity. When an activity is created, the activity enters the Created state. The onCreate() method should perform application-startup logic that happens only once for the entire life of the  activity.</p>

<p>For example, you might use onCreate() to bind data to lists, associate the activity with a ViewModel, and instantiate some class-scope variables. This method receives the parameter savedInstanceState, which is a Bundle object containing the activity's previously saved state. If the activity has never existed before, the value of the Bundle object is null.</p>

<p>If you have a lifecycle-aware component that is connected to the lifecycle of your activity, the component receives the ON_CREATE event. The method annotated with @OnLifecycleEvent is called so your lifecycle-aware component can perform any setup code it needs for the created state.</p>

<p>The following example of the onCreate() method shows fundamental setup for the activity, such as declaring the user interface (defined in an XML layout file), defining member variables, and configuring some of the UI. In this example, the XML layout file passes the file's resource ID R.layout.main_activity to setContentView().</p>               
             
<button onclick="ShowHide('onCreate', 'Java')" id="onCreateJavaButton">See example (Java)</button>
<button onclick="ShowHide('onCreate', 'Kotlin')" id="onCreateKotlinButton">See example (Kotlin)</button>
<div id="onCreateJava" style="display:none;">           
<pre>TextView textView;
// Some transient state for the activity instance.
String gameState;

@Override
public void onCreate(Bundle savedInstanceState) {
    // Call the superclass onCreate to complete the creation of
    // the activity, like the view hierarchy.
    super.onCreate(savedInstanceState);

    // Recover the instance state.
    if (savedInstanceState != null) {
        gameState = savedInstanceState.getString(GAME_STATE_KEY);
    }

    // Set the user interface layout for this activity.
    // The layout is defined in the project res/layout/main_activity.xml file.
    setContentView(R.layout.main_activity);

    // Initialize member TextView so it is available later.
    textView = (TextView) findViewById(R.id.text_view);
}

// This callback is called only when there is a saved instance previously saved using
// onSaveInstanceState(). Some state is restored in onCreate(). Other state can optionally
// be restored here, possibly usable after onStart() has completed.
// The savedInstanceState Bundle is same as the one used in onCreate().
@Override
public void onRestoreInstanceState(Bundle savedInstanceState) {
    textView.setText(savedInstanceState.getString(TEXT_VIEW_KEY));
}

// Invoked when the activity might be temporarily destroyed; save the instance state here.
@Override
public void onSaveInstanceState(Bundle outState) {
    outState.putString(GAME_STATE_KEY, gameState);
    outState.putString(TEXT_VIEW_KEY, textView.getText());

    // Call superclass to save any view hierarchy.
    super.onSaveInstanceState(outState);
}
</pre>
</div>
<div id="onCreateKotlin" style="display:none;"> 
<pre>lateinit var textView: TextView

// Some transient state for the activity instance.
var gameState: String? = null

override fun onCreate(savedInstanceState: Bundle?) {
    // Call the superclass onCreate to complete the creation of
    // the activity, like the view hierarchy.
    super.onCreate(savedInstanceState)

    // Recover the instance state.
    gameState = savedInstanceState?.getString(GAME_STATE_KEY)

    // Set the user interface layout for this activity.
    // The layout is defined in the project res/layout/main_activity.xml file.
    setContentView(R.layout.main_activity)

    // Initialize member TextView so it is available later.
    textView = findViewById(R.id.text_view)
}

// This callback is called only when there is a saved instance previously saved using
// onSaveInstanceState(). Some state is restored in onCreate(). Other state can optionally
// be restored here, possibly usable after onStart() has completed.
// The savedInstanceState Bundle is same as the one used in onCreate().
override fun onRestoreInstanceState(savedInstanceState: Bundle?) {
    textView.text = savedInstanceState?.getString(TEXT_VIEW_KEY)
}

// Invoked when the activity might be temporarily destroyed; save the instance state here.
override fun onSaveInstanceState(outState: Bundle?) {
    outState?.run {
        putString(GAME_STATE_KEY, gameState)
        putString(TEXT_VIEW_KEY, textView.text.toString())
    }
    // Call superclass to save any view hierarchy.
    super.onSaveInstanceState(outState)
}</pre>
     </div>

 <p>As an alternative to defining the XML file and passing it to setContentView(), you can create new View objects in your activity code and build a view hierarchy by inserting new View objects into a ViewGroup. You then use that layout by passing the root ViewGroup to setContentView(). For more information about creating a user interface, see the user interface documentation.</p> 
<p>Your activity does not remain in the Created state. After the onCreate() method finishes execution, the activity enters the Started state and the system calls the onStart() and onResume() methods in quick succession.</p>

<h3 id="onstart" data-text="onStart()" tabindex="-1">onStart()</h3>
<p>
When the activity enters the Started state, the system invokes onStart(). This call makes the activity visible to the user as the app prepares for the activity to enter the foreground and become interactive. For example, this method is where the code that maintains the UI is initialized.  </p>

<p>When the activity moves to the Started state, any lifecycle-aware component tied to the activity's lifecycle receives the ON_START event.

<p>The onStart() method completes quickly and, as with the Created state, the activity does not remain in the Started state. Once this callback finishes, the activity enters the Resumed state and the system invokes the onResume() method.
</p>
<h3 id="onresume" data-text="onResume()" tabindex="-1">onResume()</h3>
<p>
When the activity enters the Resumed state, it comes to the foreground, and the system invokes the onResume() callback. This is the state in which the app interacts with the user. The app stays in this state until something happens to take focus away from the app, such as the device receiving a phone call, the user navigating to another activity, or the device screen turning off. </p>

<p>When the activity moves to the Resumed state, any lifecycle-aware component tied to the activity's lifecycle receives the ON_RESUME event. This is where the lifecycle components can enable any functionality that needs to run while the component is visible and in the foreground, such as starting a camera preview.

<p>When an interruptive event occurs, the activity enters the Paused state and the system invokes the onPause() callback.

<p>If the activity returns to the Resumed state from the Paused state, the system once again calls the onResume() method. For this reason, implement onResume() to initialize components that you release during onPause() and to perform any other initializations that must occur each time the activity enters the Resumed state.

<p>Here is an example of a lifecycle-aware component that accesses the camera when the component receives the ON_RESUME event:
</p>
 <button onclick="ShowHide('onResume', 'Java')" id="onResumeJavaButton">See example (Java)</button>
<button onclick="ShowHide('onResume', 'Kotlin')" id="onResumeKotlinButton">See example(Kotlin)</button>
<div id="onResumeJava" style="display:none;">     
        
<pre>public class CameraComponent implements LifecycleObserver {

    ...

    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)
    public void initializeCamera() {
        if (camera == null) {
            getCamera();
        }
    }
    ...
}</pre>
</div>


<div id="onResumeKotlin" style="display:none;">        
             <pre>    class CameraComponent : LifecycleObserver {
    ...
    @OnLifecycleEvent(Lifecycle.Event.ON_RESUME)
    fun initializeCamera() {
        if (camera == null) {
            getCamera()
        }
    }
    ...
}      </pre>
</div> 
 
 <p>The preceding code initializes the camera once the LifecycleObserver receives the ON_RESUME event. In multi-window mode, however, your activity might be fully visible even when it is in the Paused state. For example, when the app is in multi-window mode and the user taps the window that does not contain your activity, your activity moves to the Paused state.</p>

<p>If you want the camera active only when the app is Resumed (visible and active in the foreground), then initialize the camera after the ON_RESUME event demonstrated previously. If you want to keep the camera active while the activity is Paused but visible, such as in multi-window mode, then initialize the camera after the ON_START event.</p>

<p>However, having the camera active while your activity is Paused might deny access to the camera to another Resumed app in multi-window mode. Sometimes it is necessary to keep the camera active while your activity is Paused, but it might actually degrade the overall user experience if you do.</p>

<p>For this reason, think carefully about where in the lifecycle it is most appropriate to take control of shared system resources in the context of multi-window mode. To learn more about supporting multi-window mode, see Multi-window support.</p>

<p>Regardless of which build-up event you choose to perform an initialization operation in, make sure to use the corresponding lifecycle event to release the resource. If you initialize something after the ON_START event, release or terminate it after the ON_STOP event. If you initialize after the ON_RESUME event, release after the ON_PAUSE event.</p>

<p>The preceding code example places camera initialization code in a lifecycle-aware component. You can instead put this code directly into the activity lifecycle callbacks, such as onStart() and onStop(), but we don't recommend this. Adding this logic to an independent, lifecycle-aware component lets you reuse the component across multiple activities without having to duplicate code. To learn how to create a lifecycle-aware component, see Handling Lifecycles with Lifecycle-Aware Components.
</p>

 
<h3 id="onpause" data-text="onPause()" tabindex="-1">onPause()</h3>
<p>
The system calls this method as the first indication that the user is leaving your activity, though it does not always mean the activity is being destroyed. It indicates that the activity is no longer in the foreground, but it is still visible if the user is in multi-window mode. There are several reasons why an activity might enter this state:  <ul>

<li>An event that interrupts app execution, as described in the section about the onResume() callback, pauses the current activity. This is the most common case.
<li>In multi-window mode, only one app has focus at any time, and the system pauses all other apps.
<li>The opening of a new, semi-transparent activity (for example, a dialog) pauses the activity that it covers. As long as the activity is partially visible but not in focus, the activity remains paused.</ul>
<p>
When an activity moves to the Paused state, any lifecycle-aware component tied to the activity's lifecycle receives the ON_PAUSE event. When the lifecycle component receives the event, the component can stop functions that do not need to run while the component is not in the foreground. For example, you can use the onPause() method to stop a camera preview.
  
<p>Use the OnPause() method to pause or adjust operations that can't continue, or that might continue in moderation, while the Activity is in the Paused state, and that you expect to resume shortly.</p>

<p>You can also use the onPause() method to release system resources, handles to sensors (like GPS), or any resources that affect battery life while your activity is Paused and the user does not need them.</p>

<p>However, as mentioned in the section about onResume(), a Paused activity might still be fully visible if the app is in multi-window mode. Consider using onStop() instead of onPause() to fully release or adjust UI-related resources and operations to better support multi-window mode.
</p>
<p>The following example of a LifecycleObserver reacting to the ON_PAUSE event is the counterpart to the preceding ON_RESUME event example, releasing the camera that initializes after the ON_RESUME event is received:</p>    
<button onclick="ShowHide('onPause', 'Java')" id="onPauseJavaButton">See example (Java)</button>
<button onclick="ShowHide('onPause', 'Kotlin')" id="onPauseKotlinButton">See example (Kotlin)</button>
<div id="onPauseJava" style="display:none;">                    
             <pre>public class JavaCameraComponent implements LifecycleObserver {
    ...
    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)
    public void releaseCamera() {
        if (camera != null) {
            camera.release();
            camera = null;
        }
    }
    ...
}
</pre>
</div>

</div>
<div id="onPauseKotlin" style="display:none;">                    
             <pre>public class JavaCameraComponent implements LifecycleObserver {
    ...
    @OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)
    public void releaseCamera() {
        if (camera != null) {
            camera.release();
            camera = null;
        }
    }
    ...
}
</pre>
</div>

 
<p>This example places the camera release code after the ON_PAUSE event is received by the LifecycleObserver.</p>

<p>onPause() execution is very brief and may not provider enough time to perform save operations. For this reason, don't use onPause() to save application or user data, make network calls, or execute database transactions. Such work might not complete before the method completes.</p>

<p>Instead, perform heavy-load shutdown operations during onStop(). For more information about suitable operations to perform during onStop(), see the next section. For more information about saving data, see the section about saving and restoring state.
</p>
<p>Completion of the onPause() method does not mean that the activity leaves the Paused state. Rather, the activity remains in this state until either the activity resumes or it becomes completely invisible to the user. If the activity resumes, the system once again invokes the onResume() callback.
</p>
<p>If the activity returns from the Paused state to the Resumed state, the system keeps the Activity instance resident in memory, recalling that instance when the system invokes onResume(). In this scenario, you don't need to re-initialize components created during any of the callback methods leading up to the Resumed state. If the activity becomes completely invisible, the system calls onStop().</p>      

<h3 id="onstop" data-text="onStop()" tabindex="-1">onStop()</h3>  

<p>When your activity is no longer visible to the user, it enters the Stopped state, and the system invokes the onStop() callback. This can occur when a newly launched activity covers the entire screen. The system also calls onStop() when the activity finishes running and is about to be terminated.

<p>When the activity moves to the Stopped state, every lifecycle-aware component tied to the activity's lifecycle receives the ON_STOP event. The lifecycle components can stop any functionality that does not need to run while the component is not visible on the screen.</p>

<p>In the onStop() method, release or adjust resources that are not needed while the app is not visible to the user. For example, your app might pause animations or switch from fine-grained to coarse-grained location updates. Using onStop() instead of onPause() means that UI-related work continues, even when the user is viewing your activity in multi-window mode.</p>

<p>onStop()can also perform relatively CPU-intensive shutdown operations. For example, if you can't find a better time to save information to a database, you might do so during onStop(). The following example shows an implementation of onStop() that saves the contents of a draft note to persistent storage:</p>  </p>

<button onclick="ShowHide('onStop','Java')" id="onStopJavaButton">See example (Java)</button>
<button onclick="ShowHide('onStop','Kotlin')"id="onStopKotlinButton">See example (Kotlin)</button>
<div id="onStopJava" style="display:none;">       
      <pre>@Override
protected void onStop() {
    // Call the superclass method first.
    super.onStop();

    // Save the note's current draft, because the activity is stopping
    // and we want to be sure the current note progress isn't lost.
    ContentValues values = new ContentValues();
    values.put(NotePad.Notes.COLUMN_NAME_NOTE, getCurrentNoteText());
    values.put(NotePad.Notes.COLUMN_NAME_TITLE, getCurrentNoteTitle());

    // Do this update in background on an AsyncQueryHandler or equivalent.
    asyncQueryHandler.startUpdate (
            mToken,  // int token to correlate calls
            null,    // cookie, not used here
            uri,    // The URI for the note to update.
            values,  // The map of column names and new values to apply to them.
            null,    // No SELECT criteria are used.
            null     // No WHERE columns are used.
    );
}</pre>         </div>

<div id="onStopKotlin" style="display:none;">       
 <pre>override fun onStop() {
    // Call the superclass method first.
    super.onStop()

    // Save the note's current draft, because the activity is stopping
    // and we want to be sure the current note progress isn't lost.
    val values = ContentValues().apply {
        put(NotePad.Notes.COLUMN_NAME_NOTE, getCurrentNoteText())
        put(NotePad.Notes.COLUMN_NAME_TITLE, getCurrentNoteTitle())
    }

    // Do this update in background on an AsyncQueryHandler or equivalent.
    asyncQueryHandler.startUpdate(
            token,     // int token to correlate calls
            null,      // cookie, not used here
            uri,       // The URI for the note to update.
            values,    // The map of column names and new values to apply to them.
            null,      // No SELECT criteria are used.
            null       // No WHERE columns are used.
    )
}
</pre> </div>

<p>The preceding code sample uses SQLite directly. However, we recommend using Room, a persistence library that provides an abstraction layer over SQLite. To learn more about the benefits of using Room and how to implement Room in your app, see the Room Persistence Library guide.</p>

<p>When your activity enters the Stopped state, the Activity object is kept resident in memory: it maintains all state and member information, but is not attached to the window manager. When the activity resumes, it recalls this information.</p>

<p>You don't need to re-initialize components created during any of the callback methods leading up to the Resumed state. The system also keeps track of the current state for each View object in the layout, so if the user enters text into an EditText widget, that content is retained so you don't need to save and restore it.</p>

<p>Note: Once your activity is stopped, the system might destroy the process that contains the activity if the system needs to recover memory. Even if the system destroys the process while the activity is stopped, the system still retains the state of the View objects, such as text in an EditText widget, in a Bundle (a blob of key-value pairs) and restores them if the user navigates back to the activity. For more information about restoring an activity to which a user returns, see the section about saving and restoring state.</p>

<p>From the Stopped state, the activity either comes back to interact with the user, or the activity is finished running and goes away. If the activity comes back, the system invokes onRestart(). If the Activity is finished running, the system calls onDestroy().
</p>

<h3 id="onrestart" data-text="onRestart()" tabindex="-1">onRestart()</h3>
<p>Expand limited info from Android dev docs. </p> 
<p>The system invokes this callback when an activity in the Stopped state is
about to restart. <code>onRestart()</code>
restores the state of the activity from the time that it was stopped.
</p>
<p>
This callback is always followed by
<code>onStart()</code>.
</p>
<h3 id="ondestroy" data-text="onDestroy()" tabindex="-1">onDestroy()</h3>
 <p>
The onDestroy() callback releases all resources not released by earlier callbacks, such as onStop().
</p>
<p>onDestroy() is called before the activity is destroyed. The system invokes this callback for one of two reasons:</p>

<ul><li>The activity is finishing, due to the user completely dismissing the activity or due to finish() being called on the activity.</li>
<li>The system is temporarily destroying the activity due to a configuration change, such as device rotation or entering multi-window mode.</li>     </ul>
<p>When the activity moves to the destroyed state, any lifecycle-aware component tied to the activity's lifecycle receives the ON_DESTROY event. This enables lifecycle components to clean up anything they need to before the Activity is destroyed.</p>

<p>Instead of putting logic in your Activity to determine why it is being destroyed, use a ViewModel object to contain the relevant view data for your Activity. If the Activity is recreated due to a configuration change, the ViewModel does not have to do anything, since it is preserved and given to the next Activity instance.</p>

<p>If the Activity isn't recreated, then the ViewModel has the onCleared() method called, where it can clean up any data it needs to before being destroyed. You can distinguish between these two scenarios with the isFinishing() method.
</p>
<p>If the activity is finishing, onDestroy() is the final lifecycle callback that the activity receives. If onDestroy() is called as the result of a configuration change, the system immediately creates a new activity instance and then calls onCreate() on that new instance in the new configuration.</p>

<h2> Activity state and ejection from memory</h2>
<p>The system kills processes when it needs to free up RAM. The chance of the system killing a specific process depends on the state of the process at the time. Process state depends on the state of the activity running in the process.</p>  <p>The table shows the relations between process state, activity state, and the likelihood of the system killing the process. This table only applies if a process is not running other types of application components.</p>  

<table style="font-size: 12px;">
  <tr>
    <th>Likelihood of being killed</th>
    <th>Process state</th>   
       <th>Final activity state</th>
  </tr>
  
<tr>
<td>Lowest	
</td>
<td>Foreground (having or about to get focus)</td>
<td>	Resumed</td>
</tr>
<tr><td>Low	
</td><td>Visible (no focus)	</td>
<td>Started/Paused</td></tr>

<tr><td>Higher</td>	
<td>Background (invisible)</td>
<td>Stopped</td></tr>

<tr><td>Highest</td>	
<td>Empty</td>
<td>Destroyed</td></tr>
 </table>
   <p>The system never kills an activity directly to free up memory. Instead, it kills the process the activity runs in, destroying not only the activity but everything else running in the process as well. To learn how to preserve and restore your activity's UI state when system-initiated process death occurs, see the section about saving and restoring state.</p>
<p>
The user can also kill a process by killing the corresponding app. This feature is located in the App Management section of Settings. The exact location and name of the feature depends on the type and version of Android in use on the device.</p>

<p>For more information about processes, see Processes and threads overview.</p>
<h2>Saving and restoring transient UI state</h2> 
<p>A user expects an activity's UI state to remain the same during a configuration change (for example, screen rotation or switching into multi-window mode). However, when that kind of configuration change occurs, the system destroys the activity by default and clears any UI state stored in the activity instance.</p>

<p>Similarly, a user expects UI state to remain the same if they temporarily switch away from your app to a different app and then return to your app later. However, the system can destroy your application's process while the user is away and your application's activity is stopped.</p>

<p>When system constraints destroy the activity, you can preserve the user's transient UI state using a combination of ViewModel, onSaveInstanceState(), and/or local storage. To learn more about user expectations compared to system behavior and how to best preserve complex UI state data across system-initiated activity and process death, see <b>Save UI states</b>.</p>

<p>This section outlines what instance state is and how to implement the onSaveInstance() method, which is a callback on the activity itself. If your UI data is lightweight, you can use onSaveInstance() alone to persist the UI state across both configuration changes and system-initiated process death. But because onSaveInstance() incurs serialization/deserialization costs, in most cases you use both ViewModel and onSaveInstance(), as outlined in <b>Save UI states</b>.
</p>
<p>Note: To learn more about configuration changes; how to restrict activity recreation if needed, and how to react to those configuration changes from the View system and Jetpack Compose, check out the <b>Handle configuration changes page</b>.</p>
<h3> Instance state</h3>  
<p>In some scenarios, your activity is destroyed due to normal app behavior. Examples include when the user presses the Back button or when your activity signals its own destruction by calling the finish() method.
</p>
<p>When your activity is destroyed for one of those reasons, both the system's and the user's concept of that Activity instance is gone forever. In these scenarios, the user's expectation matches the system's behavior, and no extra work is required.</p>

<p>However, if the system destroys the activity because of system constraints (such as a configuration change or memory pressure), the system remembers that the Activity instance existed even though the actual Activity instance is gone. If the user attempts to navigate back to the activity, the system creates a new instance of that activity using a set of saved data that describes the state of the activity when it was destroyed.
</p>
<p>The saved data that the system uses to restore the previous state is called the instance state. The instance state is a collection of key-value pairs stored in a Bundle object. By default, the system uses the Bundle instance state to save information about each View object in your activity layout, such as the text value entered into an EditText widget.</p>

<p>In this case, if your activity instance is destroyed and recreated, the state of the layout is restored to its previous state without requiring you to provide additional code required. However, you may want to restore more state information to your activity such as member variables that track the user's progress in the activity.</p>

<p><b>Note: For the Android system to restore the state of the views in your activity, each view must have a unique ID, supplied by the android:id attribute</b>.</p>

<p>Vecause a Bundle object requires serialization on the main thread and consumes system-process memory, a Bundle object should not be used to preserve more than a trivial amount of data. If you need to preserve more than a very small amount of data, take a combined approach to preserving data using <b>persistent local storage, the onSaveInstanceState() method, and the ViewModel class, as outlined in Save UI states.</b></p>       
<h3>Save simple, lightweight UI state using onSaveInstanceState()</h3>
<p>As your activity begins to stop, the system calls the onSaveInstanceState() method so your activity can save state information to an instance state bundle. The default implementation of this method saves transient information about the state of the activity's view hierarchy, such as the text in an EditText widget or the scroll position of a ListView widget.</p>

<p>To save additional instance state information for your activity, override onSaveInstanceState() and add key-value pairs to the Bundle object that is saved in the event that your activity is destroyed unexpectedly. When you override onSaveInstanceState(), you need to call the superclass implementation if you want the default implementation to save the state of the view hierarchy. This is shown in the following example:</p>


               

 <p>Note: onSaveInstanceState() is not called when the user explicitly closes the activity or in other cases when finish() is called.</p>
<p>
To save persistent data, such as user preferences or data for a database, take appropriate opportunities when your activity is in the foreground. If no such opportunity arises, save persistent data during the onStop() method.</p>

<h3>Restore activity UI state using saved instance state</h3>
<p>When your activity is recreated after it was previously destroyed, you can recover your saved instance state from the Bundle that the system passes to your activity. Both the onCreate() and onRestoreInstanceState() callback methods receive the same Bundle that contains the instance state information.</p>

<p>Because the onCreate() method is called whether the system is creating a new instance of your activity or recreating a previous one, you need to check whether the state Bundle is null before you attempt to read it. If it is null, then the system is creating a new instance of the activity, instead of restoring a previous one that was destroyed.</p>


<p>Instead of restoring the state during onCreate(), you can choose to implement onRestoreInstanceState(), which the system calls after the onStart() method. The system calls onRestoreInstanceState() only if there is a saved state to restore, so you do not need to check whether the Bundle is null.</p>
<p><b>Caution</b>: Always call the superclass implementation of onRestoreInstanceState() so the default implementation can restore the state of the view hierarchy.</p>
<h2>Navigating between activities
</h2><p>An app is likely to enter and exit an activity, perhaps many times, during the app's lifetime, such as when the user taps the device's Back button or the activity launches a different activity.</p>
<p>
This section covers topics you need to know to implement successful activity transitions. These topics include starting an activity from another activity, saving activity state, and restoring activity state.</p> 
 
<h3>Starting one activity from another</h3>
<p>Sometimes an activity needs to start another activity. For example, when an app needs to move from the current screen to a new one.</p>

<p>Depending on whether or not your activity wants a result back from the new activity it's about to start, you start the new activity using either the startActivity() method or the startActivityForResult() method. In either case, you pass in an Intent object.</p>

<p>The Intent object specifies either the exact activity you want to start or describes the type of action you want to perform. The system selects the appropriate activity for you, which can even be from a different application. An Intent object can also carry small amounts of data to be used by the activity that is started. For more information about the Intent class, see<b> Intents and Intent Filters</b>.</p>
<h3>startActivity()</h3>
<p>If the newly started activity does not need to return a result, the current activity can start it by calling the startActivity() method.</p>

<p>When working within your own application, you often need to simply launch a known activity. For example, the following code snippet shows how to launch an activity called SignInActivity.</p>

<p>Your application might want to perform some action (such as sending an email, text message, or status update) using data from your activity. In this case, if your application does not have its own activities to perform such actions, you can leverage the activities provided by other applications on the device that can perform the actions for you.
</p>
<p>To handle a case like this, you can create an intent that describes an action you want to perform, and the system will launch the appropriate activity from another application. If multiple activities are available that can handle the intent, the user can select which one to use. For example, if you want to let the user send an email message, you can create the following intent:</p>


<p>The EXTRA_EMAIL extra added to the intent is a string array of email addresses the email is to be sent to. When an email application responds to this intent, it reads the string array provided in the extra and places the addresses in the "to" field of the email composition form. In this situation, the email application's activity starts. When the user is done with the email, your activity resumes.</p>     


<h3><a name="startActivityForResult"><a name="startActivity"></a></a>startActivityForResult()</h3>
<p>You can get a result back from an activity when it ends. For example, consider an activity that lets the user pick a person in a list of contacts. When the activity ends, it returns the person that was selected. To do this, you call the startActivityForResult(Intent, int) method, where the integer parameter identifies the call.</p>

<p>This identifier distinguishes between multiple calls to startActivityForResult(Intent, int) from the same activity. It is not a global identifier and is not at risk of conflicting with other apps or activities. The result is returned through your onActivityResult(int, int, Intent) method.</p>
<p>
When a child activity exits, it can call setResult(int) to return data to its parent. The child activity must supply a result code, which can be the standard results RESULT_CANCELED, RESULT_OK, or any custom values starting at RESULT_FIRST_USER.</p>

<p>In addition, the child activity can optionally return an Intent object containing any additional data. The parent activity uses the onActivityResult(int, int, Intent) method and the integer identifier that the parent activity originally supplied to receive the information.
</p>
<p>If a child activity fails for any reason (such as crashing), the parent activity receives a result with the code RESULT_CANCELED.</p>
<h2>Coordinating activities<a name="activities_coordinate"></a></h2>
<p>When one activity starts another, both activities enter a lifecycle transition: The first activity stops operating and enters the Paused or Stopped state while the other activity is created. The first activity is <b>not</b> completely stopped before the second one is created. The process of starting the second activity overlaps with the process of stopping the first one.  </p>

<p> K In case these activities share data saved to disk or elsewhere, it's important to understand that the first activity is <b>not</b> completely stopped before the second one is created. Again, the process of starting the second one overlaps with the process of stopping the first one.</p>

<p>The order of lifecycle callback operations when Activity A starts Activity B is the following:
</p>        <ol>
<li>Activity A's onPause() method executes.</li>
<li>Activity B's onCreate(), onStart(), and onResume() methods execute in sequence. Activity B now has user focus.</li> 
<li>If Activity A is no longer visible on screen, its onStop() method executes.
</li>
                             </ol>
              <p>This sequence of lifecycle callbacks lets you manage the transition of information from one activity to another.</p>